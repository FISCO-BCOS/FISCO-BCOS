/*
	This file is part of FISCO-BCOS.

	FISCO-BCOS is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	FISCO-BCOS is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with FISCO-BCOS.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file RLPXHandshakeSSL.h
 * @author toxotguo
 * @date 2018
 */


#pragma once

#include <memory>
#include <libdevcrypto/Common.h>
#include <libdevcrypto/ECDHE.h>
#include "RLPXSocketSSL.h"
#include "RLPXFrameCoder.h"
#include "Common.h"
#include "Host.h"

#include "HandshakeCAData.h"

namespace ba = boost::asio;
namespace bi = boost::asio::ip;

namespace dev
{
namespace p2p
{

class RLPXHandshakeSSL: public std::enable_shared_from_this<RLPXHandshakeSSL>
{
	friend class RLPXFrameCoder;

public:
	/// Setup incoming connection.
	RLPXHandshakeSSL(HostApi* _host, std::shared_ptr<RLPXSocketSSL> const& _socket): m_host(_host), m_originated(false), m_socket(_socket), m_idleTimer(m_socket->ref().get_io_service())
	{ 
		crypto::Nonce::get().ref().copyTo(m_nonce.ref());
		m_strand=_host->getStrand();
	}
	/// Setup outbound connection.
	RLPXHandshakeSSL(HostApi* _host, std::shared_ptr<RLPXSocketSSL> const& _socket, NodeID _remote): m_host(_host), m_remote(_remote), m_originated(true), m_socket(_socket), m_idleTimer(m_socket->ref().get_io_service())
	{
		crypto::Nonce::get().ref().copyTo(m_nonce.ref()); 
		m_strand=_host->getStrand();
	}

	~RLPXHandshakeSSL() {}

	/// Start handshake.
	void start() { transition(); }

	/// Aborts the handshake.
	void cancel();

protected:
	/// Sequential states of handshake
	enum State
	{
		Error = -1,
		WriteHello,
		ReadHello,
        StartSession
	};

	
	/// Closes connection and ends transitions.
	void error();
	
	/// Performs transition for m_nextState.
	virtual void transition(boost::system::error_code _ech = boost::system::error_code());

	/// Timeout for remote to respond to transition events. Enforced by m_idleTimer and refreshed by transition().
	boost::posix_time::milliseconds const c_timeout = boost::posix_time::milliseconds(10000);

	State m_nextState = WriteHello;			///< Current or expected state of transition.
	bool m_cancel = false;			///< Will be set to true if connection was canceled.
	
	HostApi* m_host;					///< Host which provides m_alias, protocolVersion(), m_clientVersion, caps(), and TCP listenPort().
	
	/// Node id of remote host for socket.
	NodeID m_remote;					///< Public address of remote host.
	bool m_originated = false;		///< True if connection is outbound.
	
	/// Buffers for encoded and decoded handshake phases
	bytes m_auth;					///< Plaintext of egress or ingress Auth message.
	bytes m_authCipher;				///< Ciphertext of egress or ingress Auth message.
	bytes m_ack;						///< Plaintext of egress or ingress Ack message.
	bytes m_ackCipher;				///< Ciphertext of egress or ingress Ack message.
	bytes m_handshakeOutBuffer;		///< Frame buffer for egress Hello packet.
	bytes m_handshakeInBuffer;		///< Frame buffer for ingress Hello packet.

	///CA
	RLPBaseData m_readBaseData;
	RLPBaseData m_sendBaseData;

	crypto::ECDHE m_ecdhe;			///< Ephemeral ECDH secret and agreement.
	h256 m_nonce;					///< Nonce generated by this host for handshake.
	
	Public m_remoteEphemeral;			///< Remote ephemeral public key.
	h256 m_remoteNonce;				///< Nonce generated by remote host for handshake.
	uint64_t m_remoteVersion;
	
	/// Used to read and write RLPx encrypted frames for last step of handshake authentication.
	/// Passed onto Host which will take ownership.
	std::unique_ptr<RLPXFrameCoder> m_io;
	
	std::shared_ptr<RLPXSocketSSL> m_socket;		///< Socket.
	boost::asio::deadline_timer m_idleTimer;	///< Timer which enforces c_timeout.

	boost::asio::io_service::strand* m_strand;
};
	
}
}
