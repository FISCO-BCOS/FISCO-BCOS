// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.3.
// **********************************************************************

#pragma once
#include "bcos-cpp-sdk/utilities/tx/tars/tup/Tars.h"
#include "bcos-cpp-sdk/utilities/tx/tars/tup/TarsJson.h"
#include <bcos-crypto/interfaces/crypto/Hash.h>
#include <bcos-utilities/DataConvertUtility.h>
#include <boost/asio/detail/socket_ops.hpp>
#include <boost/endian/conversion.hpp>
#include <map>
#include <string>
#include <vector>

namespace bcostars
{
struct LogEntry : public tars::TarsStructBase
{
public:
    static std::string className() { return "bcostars.LogEntry"; }
    static std::string MD5() { return "62d086d520cb1c44d615aec11186ef08"; }
    void resetDefault()
    {
        address = "";
        topic.clear();
        data.clear();
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        if (address != "")
        {
            _os.write(address, 1);
        }
        if (topic.size() > 0)
        {
            _os.write(topic, 2);
        }
        if (data.size() > 0)
        {
            _os.write(data, 3);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefault();
        _is.read(address, 1, false);
        _is.read(topic, 2, false);
        _is.read(data, 3, false);
    }
    [[nodiscard]] tars::JsonValueObjPtr writeToJson() const
    {
        tars::JsonValueObjPtr p = new tars::JsonValueObj();
        p->value["address"] = tars::JsonOutput::writeJson(address);
        std::vector<std::string> topics;
        topics.resize(topic.size());
        for (const auto& item : topic)
        {
            std::string hex = bcos::toHex(item);
            topics.push_back(std::move(hex));
        }
        p->value["topics"] = tars::JsonOutput::writeJson(topics);
        p->value["data"] = tars::JsonOutput::writeJson(bcos::toHexStringWithPrefix(data));
        return p;
    }
    void readFromJson(const tars::JsonValuePtr& p, bool isRequire = true)
    {
        resetDefault();
        if (nullptr == p.get() || p->getType() != tars::eJsonTypeObj)
        {
            char s[128];
            snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.",
                (p.get() ? p->getType() : 0));
            throw tars::TC_Json_Exception(s);
        }
        tars::JsonValueObjPtr pObj = tars::JsonValueObjPtr::dynamicCast(p);
        tars::JsonInput::readJson(address, pObj->value["address"], true);

        auto topics = pObj->value["topics"];
        if (topics && topics->getType() == tars::eJsonTypeArray)
        {
            auto* pArray = dynamic_cast<tars::JsonValueArray*>(topics.get());
            topic.resize(pArray->value.size());
            size_t i = 0;
            for (auto it = pArray->value.begin(); it != pArray->value.end(); ++it, ++i)
            {
                std::string topicHex{};
                tars::JsonInput::readJson(topicHex, *it, true);
                auto topicBytes = bcos::fromHexString(topicHex);
                std::copy(topicBytes->begin(), topicBytes->end(), std::back_inserter(topic[i]));
            }
        }

        std::string dataHex{};
        tars::JsonInput::readJson(dataHex, pObj->value["data"], true);
        auto dataBytes = bcos::fromHexString(dataHex);
        std::copy(dataBytes->begin(), dataBytes->end(), std::back_inserter(data));
    }
    std::ostream& display(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(address, "address");
        _ds.display(topic, "topic");
        _ds.display(data, "data");
        return _os;
    }
    std::ostream& displaySimple(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(address, true);
        _ds.displaySimple(topic, true);
        _ds.displaySimple(data, false);
        return _os;
    }

public:
    std::string address;
    std::vector<std::vector<tars::Char> > topic;
    std::vector<tars::Char> data;
};
inline bool operator==(const LogEntry& l, const LogEntry& r)
{
    return l.address == r.address && l.topic == r.topic && l.data == r.data;
}
inline bool operator!=(const LogEntry& l, const LogEntry& r)
{
    return !(l == r);
}

struct TransactionReceiptData : public tars::TarsStructBase
{
public:
    static std::string className() { return "bcostars.TransactionReceiptData"; }
    static std::string MD5() { return "2e0147a8f94f43a2c1d0113c0432886e"; }
    TransactionReceiptData() { resetDefault(); }
    void resetDefault()
    {
        version = 0;
        gasUsed = "";
        contractAddress = "";
        status = 0;
        output.clear();
        logEntries.clear();
        blockNumber = 0;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(version, 1);
        if (gasUsed != "")
        {
            _os.write(gasUsed, 2);
        }
        if (contractAddress != "")
        {
            _os.write(contractAddress, 3);
        }
        if (status != 0)
        {
            _os.write(status, 4);
        }
        if (output.size() > 0)
        {
            _os.write(output, 5);
        }
        if (logEntries.size() > 0)
        {
            _os.write(logEntries, 6);
        }
        if (blockNumber != 0)
        {
            _os.write(blockNumber, 7);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefault();
        _is.read(version, 1, true);
        _is.read(gasUsed, 2, false);
        _is.read(contractAddress, 3, false);
        _is.read(status, 4, false);
        _is.read(output, 5, false);
        _is.read(logEntries, 6, false);
        _is.read(blockNumber, 7, false);
    }
    [[nodiscard]] tars::JsonValueObjPtr writeToJson() const
    {
        tars::JsonValueObjPtr p = new tars::JsonValueObj();
        p->value["version"] = tars::JsonOutput::writeJson(version);
        p->value["gasUsed"] = tars::JsonOutput::writeJson(gasUsed);
        p->value["contractAddress"] = tars::JsonOutput::writeJson(contractAddress);
        p->value["status"] = tars::JsonOutput::writeJson(status);
        p->value["output"] = tars::JsonOutput::writeJson(bcos::toHexStringWithPrefix(output));
        p->value["logEntries"] = tars::JsonOutput::writeJson(logEntries);
        p->value["blockNumber"] = tars::JsonOutput::writeJson(blockNumber);
        return p;
    }
    [[nodiscard]] std::string writeToJsonString() const
    {
        return tars::TC_Json::writeValue(writeToJson());
    }

    void readFromJson(const tars::JsonValuePtr& p, bool isRequire = true)
    {
        resetDefault();
        if (nullptr == p.get() || p->getType() != tars::eJsonTypeObj)
        {
            char s[128];
            snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.",
                (p.get() ? p->getType() : 0));
            throw tars::TC_Json_Exception(s);
        }
        tars::JsonValueObjPtr pObj = tars::JsonValueObjPtr::dynamicCast(p);
        tars::JsonInput::readJson(version, pObj->value["version"], true);
        tars::JsonInput::readJson(gasUsed, pObj->value["gasUsed"], true);
        tars::JsonInput::readJson(contractAddress, pObj->value["contractAddress"], true);
        tars::JsonInput::readJson(status, pObj->value["status"], true);

        std::string outputHex{};
        tars::JsonInput::readJson(outputHex, pObj->value["output"], true);
        auto outputBytes = bcos::fromHexString(outputHex);
        std::copy(outputBytes->begin(), outputBytes->end(), std::back_inserter(output));

        tars::JsonInput::readJson(logEntries, pObj->value["logEntries"], false);
        tars::JsonInput::readJson(blockNumber, pObj->value["blockNumber"], true);
    }
    void readFromJsonString(const std::string& str) { readFromJson(tars::TC_Json::getValue(str)); }
    std::ostream& display(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(version, "version");
        _ds.display(gasUsed, "gasUsed");
        _ds.display(contractAddress, "contractAddress");
        _ds.display(status, "status");
        _ds.display(output, "output");
        _ds.display(logEntries, "logEntries");
        _ds.display(blockNumber, "blockNumber");
        return _os;
    }
    std::ostream& displaySimple(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(version, true);
        _ds.displaySimple(gasUsed, true);
        _ds.displaySimple(contractAddress, true);
        _ds.displaySimple(status, true);
        _ds.displaySimple(output, true);
        _ds.displaySimple(logEntries, true);
        _ds.displaySimple(blockNumber, false);
        return _os;
    }

    [[nodiscard]] bcos::crypto::HashType hash(bcos::crypto::Hash::Ptr _hashImpl) const
    {
        auto anyHasher = _hashImpl->hasher();
        bcos::crypto::HashType hashResult;
        std::visit(
            [this, &hashResult](auto& hasher) {
                // encode version
                int32_t networkVersion = boost::endian::native_to_big((int32_t)version);
                hasher.update(networkVersion);
                // gas used
                hasher.update(bcos::bytesConstRef((bcos::byte*)gasUsed.data(), gasUsed.size()));
                // address
                hasher.update(bcos::bytesConstRef((bcos::byte*)contractAddress.data(), contractAddress.size()));
                // status
                int32_t receiptStatus = boost::endian::native_to_big((int32_t)status);
                hasher.update(bcos::bytesConstRef((bcos::byte*)(&receiptStatus),
                                           sizeof(receiptStatus) / sizeof(uint8_t)));
                // output
                hasher.update(bcos::bytesConstRef((bcos::byte*)output.data(), output.size()));
                // logEntries
                for (const auto& log : logEntries)
                {
                    // log address
                    hasher.update(bcos::bytesConstRef((bcos::byte*)log.address.data(), log.address.size()));
                    // log topic
                    for (const auto& item : log.topic)
                    {
                        hasher.update(bcos::bytesConstRef((bcos::byte*)item.data(), item.size()));
                    }
                    // log data
                    hasher.update(bcos::bytesConstRef((bcos::byte*)log.data.data(), log.data.size()));
                }
                // block number
                int64_t receiptBlockNumber = boost::endian::native_to_big((int64_t)blockNumber);
                hasher.update(bcos::bytesConstRef((bcos::byte*)(&receiptBlockNumber),
                                           sizeof(receiptBlockNumber) / sizeof(uint8_t)));

                hasher.final(hashResult);
            },
            anyHasher);

        return hashResult;
    }

public:
    tars::Int32 version;
    std::string gasUsed;
    std::string contractAddress;
    tars::Int32 status;
    std::vector<tars::Char> output;
    std::vector<bcostars::LogEntry> logEntries;
    tars::Int64 blockNumber;
};
inline bool operator==(const TransactionReceiptData& l, const TransactionReceiptData& r)
{
    return l.version == r.version && l.gasUsed == r.gasUsed &&
           l.contractAddress == r.contractAddress && l.status == r.status && l.output == r.output &&
           l.logEntries == r.logEntries && l.blockNumber == r.blockNumber;
}
inline bool operator!=(const TransactionReceiptData& l, const TransactionReceiptData& r)
{
    return !(l == r);
}

struct TransactionReceipt : public tars::TarsStructBase
{
public:
    static std::string className() { return "bcostars.TransactionReceipt"; }
    static std::string MD5() { return "536d257977d784307824953e3cf16980"; }
    TransactionReceipt() { resetDefault(); }
    void resetDefault()
    {
        data.resetDefault();
        dataHash.clear();
        message = "";
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(data, 1);
        if (dataHash.size() > 0)
        {
            _os.write(dataHash, 2);
        }
        if (message != "")
        {
            _os.write(message, 3);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefault();
        _is.read(data, 1, false);
        _is.read(dataHash, 2, false);
        _is.read(message, 3, false);
    }
    std::ostream& display(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(data, "data");
        _ds.display(dataHash, "dataHash");
        _ds.display(message, "message");
        return _os;
    }
    std::ostream& displaySimple(std::ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(data, true);
        _ds.displaySimple(dataHash, true);
        _ds.displaySimple(message, false);
        return _os;
    }

public:
    bcostars::TransactionReceiptData data;
    std::vector<tars::Char> dataHash;
    std::string message;
};
inline bool operator==(const TransactionReceipt& l, const TransactionReceipt& r)
{
    return l.data == r.data && l.dataHash == r.dataHash && l.message == r.message;
}
inline bool operator!=(const TransactionReceipt& l, const TransactionReceipt& r)
{
    return !(l == r);
}
using ReceiptDataUniquePtr = std::unique_ptr<TransactionReceiptData>;
using ReceiptUniquePtr = std::unique_ptr<TransactionReceipt>;
}  // namespace bcostars
